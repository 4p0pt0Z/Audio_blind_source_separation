import os
from scipy.signal import stft
import librosa
import numpy as np
import h5py
import collections
from collections import defaultdict
import json
import sklearn
from iterstrat.ml_stratifiers import MultilabelStratifiedShuffleSplit
import gc
import argparse

from helpers import str2bool


def parse_label_file(filename, classes_list):
    """

    Args:
        filename (str): path to the label file (.txt file as generated by cloud-factory when labelling the segments)
        classes_list (list): List of str: The classes susceptible to be present in the label file

    Returns:
        List of length len(classes_list). Each elements contains the starting and ending times (if any) of the
        labelled portion of the segment, for a class
    """
    # read label file content
    with open(filename, 'r') as file:
        lines = file.readlines()
    lines = [x.strip() for x in lines]
    # Parse the time stamps per classes if any
    timestamps = []
    for a_class in classes_list:
        # find idx of line with the class name
        class_line_idx = [idx for idx, line in enumerate(lines)
                          if line.find(a_class) > - 1
                          and line.find('.eaf') == -1
                          and line.find('AM') == -1
                          and line.find('PM') == -1]
        for line_idx_idx, line_idx in enumerate(class_line_idx):
            # time stamps should be the line after the class name
            segments_lines_idx = line_idx + 1

            if segments_lines_idx < len(lines):
                if line_idx_idx == 0:
                    timestamps.append(np.array(list(
                        map(float, filter(None,
                                          lines[segments_lines_idx].replace('TC', '')
                                          .replace('-', '\t')
                                          .replace('00:00:', '').split('\t'))))))
                else:
                    additional_line_timestamps = np.array(list(
                        map(float, filter(None,
                                          lines[segments_lines_idx].replace('TC', '')
                                          .replace('-', '\t')
                                          .replace('00:00:', '').split('\t')))))
                    timestamps[-1] = np.array(timestamps[-1].tolist() + additional_line_timestamps.tolist())
            else:
                timestamps.append(np.array([]))  # Sometimes the class name is present but there are no timestamps
        # class name is not present in the label file
        if not class_line_idx:
            timestamps.append(np.array([]))  # Sometimes there is no class name and no timestamps

    return timestamps


def label_duration_in_segments(segment_start, segment_end, label_start_times, label_end_times):
    """

    Args:
        segment_start (float): start time of audio segment in second
        segment_end (float): end time of audio segment in second
        label_start_times (np.ndarra): 1d array: contains the starting times of the labelled portions of the segment
        label_end_times (np.ndarray): 1d array: contains the ending times of the labelled portions of the segment

    Returns:

    """
    smaller_start_times = label_start_times[label_start_times <= segment_end]
    greater_end_times = label_end_times[label_end_times >= segment_start]
    if smaller_start_times.size == 0 or greater_end_times.size == 0:
        return 0.0
    in_seg_start_times = smaller_start_times[smaller_start_times >= segment_start]
    in_seg_end_times = greater_end_times[greater_end_times <= segment_end]
    if in_seg_end_times.size == 0:
        in_seg_end_times = np.array([segment_end])
    if in_seg_start_times.size == 0:
        in_seg_start_times = np.array([segment_start])

    duration = 0.0
    if in_seg_end_times[0] <= in_seg_start_times[0]:
        duration += in_seg_end_times[0] - segment_start
        in_seg_end_times = in_seg_end_times[1:]
    if in_seg_end_times.size == 0 or in_seg_start_times[-1] >= in_seg_end_times[-1]:
        duration += segment_end - in_seg_start_times[-1]
        in_seg_start_times = in_seg_start_times[:-1]
    duration += np.sum(in_seg_end_times - in_seg_start_times)

    return duration


def generate_segments(all_wavs_filenames, all_labels_filenames, config, classes,
                      STFT_frame_n_samples, STFT_frame_n_samples_shift, segment_n_samples, round_segments_length_s):
    labels = collections.deque()
    durations = collections.deque()
    mel_spectrograms = collections.deque()
    stft_magnitudes = collections.deque()
    stft_phases = collections.deque()
    segment_names = collections.deque()

    mel_filterbank = librosa.filters.mel(config["sampling_rate"],
                                         n_fft=STFT_frame_n_samples,
                                         n_mels=config["n_Mel_filters"],
                                         fmin=config["Mel_min_freq"],
                                         fmax=config["Mel_max_freq"])

    for idx, (audio_file, label_file) in enumerate(zip(all_wavs_filenames, all_labels_filenames)):
        try:
            audio, _ = librosa.core.load(audio_file, sr=config["sampling_rate"], mono=True)
            labels_segment = parse_label_file(label_file, classes)
            if len(labels_segment) != len(classes):
                raise ValueError(
                    'Length of labels_segment is ' + str(len(labels_segment)) + ' while there are only ' + str(
                        len(classes)) + ' classes.')
        except Exception as e:
            print(e)
            print(audio_file)
            continue

        n_seg_in_audio = audio.shape[0] // segment_n_samples
        audio = audio[:n_seg_in_audio * segment_n_samples]
        segments = np.split(audio, n_seg_in_audio)

        for seg_idx in range(len(segments)):
            if config['Add_gaussian_noise']:
                noise = np.random.normal(0.0, 1.0, segments[seg_idx].shape[0])
                signal_power = np.sum(segments[seg_idx] * segments[seg_idx]) / segments[seg_idx].shape[0]
                noise_power = np.sum(noise * noise) / noise.shape[0]
                K = (signal_power / noise_power) * np.power(10, -config['G_noise_SNR_in_dB'] / 10.0)
                segments[seg_idx] += np.sqrt(K) * noise

            try:
                durations.append(np.array([label_duration_in_segments(seg_idx * round_segments_length_s,
                                                                      (seg_idx + 1) * round_segments_length_s,
                                                                      class_label_segments[::2],
                                                                      class_label_segments[1::2])
                                           for class_label_segments in labels_segment]))
            except Exception as e:
                print(e, labels_segment)
            # The segment get a label for a class if at least 4 frame in the segment has the label
            seg_labels = (np.array(durations[-1]) >= 4.0 * config["STFT_frame_width_ms"] / 1000.0)
            labels.append(seg_labels)

            _, _, seg_stft = stft(segments[seg_idx],
                                  window=config["STFT_window_function"],
                                  nperseg=STFT_frame_n_samples,
                                  noverlap=STFT_frame_n_samples - STFT_frame_n_samples_shift,
                                  detrend=config["detrend"],
                                  boundary=config["boundary"],
                                  padded=config["padded"])

            stft_magnitudes.append(np.abs(seg_stft))
            stft_phases.append(seg_stft / (stft_magnitudes[-1] + 1e-15))

            mel_spectrograms.append(mel_filterbank @ stft_magnitudes[-1])

            name = os.path.join(config["output_folder"],
                                os.path.splitext(os.path.basename(audio_file))[0]
                                + '_seg{}'.format(seg_idx) + '.wav')
            segment_names.append(os.path.basename(name))
            librosa.output.write_wav(name, segments[seg_idx], sr=config["sampling_rate"], norm=False)

    return np.array(stft_magnitudes, dtype=np.float32), \
           np.array(stft_phases, dtype=np.complex64), \
           np.array(mel_spectrograms, dtype=np.float32), \
           np.array(labels, dtype=np.float32), \
           np.array(segment_names), \
           np.array(durations, dtype=np.float32)


def merge_remove_duplicates(stft_magnitudes, stft_phases, mel_spectrograms, labels, segment_names, durations):
    """
        Merge duplicate segments which have been labelled for 2 distinct category independently
    Args:
        stft_magnitudes ():
        stft_phases ():
        mel_spectrograms ():
        labels ():
        segment_names ():
        durations ():

    Returns:
        Merged features
    """

    def list_duplicates(seq):
        """ Returns a dict which keys are the duplicates value in the list, and the values are the duplicates
        indices. """
        tally = defaultdict(list)
        for i, item in enumerate(seq):
            tally[item].append(i)
        return ((key, locs) for key, locs in tally.items()
                if len(locs) > 1)

    duplicates = dict(list_duplicates(segment_names))

    # merge the labels and durations
    for _, value in duplicates.items():
        for duplicate_idx in value[1:]:
            labels[value[0]] = np.maximum(labels[value[0]], labels[duplicate_idx])
            # Do not add the duration for the 'Human Speech' class as it is labelled in both files !
            durations[value[0]][:-1] += durations[duplicate_idx][:-1]
            # Instead, take the mean (equal trust given to each label)
            durations[value[0]][-1] = np.mean([durations[value[0]][-1], durations[duplicate_idx][-1]])

    to_remove_indices = [index for indices in duplicates.values() for index in indices[1:]]

    # # remove
    # mask = np.ones(stft_magnitudes.shape[0], dtype=bool)
    # mask[to_remove_indices] = False
    # stft_magnitudes = stft_magnitudes[mask, ...]
    # stft_phases = stft_phases[mask, ...]
    # mel_spectrograms = mel_spectrograms[mask, ...]
    # labels = labels[mask, ...]
    # segment_names = segment_names[mask, ...]
    # durations = durations[mask, ...]

    return np.delete(stft_magnitudes, to_remove_indices, axis=0), \
           np.delete(stft_phases, to_remove_indices, axis=0), \
           np.delete(mel_spectrograms, to_remove_indices, axis=0), \
           np.delete(labels, to_remove_indices, axis=0), \
           np.delete(segment_names, to_remove_indices, axis=0), \
           np.delete(durations, to_remove_indices, axis=0)


def save_features(save_path, stft_magnitudes, stft_phases, mel_spectrograms, labels, segment_names, durations):
    with h5py.File(save_path, 'w') as hdf5_file:
        hdf5_file.create_dataset('stft_magnitudes', data=stft_magnitudes)
        hdf5_file.create_dataset('stft_phases', data=stft_phases)
        hdf5_file.create_dataset('mel_spectrograms', data=mel_spectrograms)
        hdf5_file.create_dataset('labels', data=labels)
        hdf5_file.create_dataset('filenames', data=[filename.encode("ascii", "ignore") for filename in segment_names])
        hdf5_file.create_dataset('durations', data=durations)


def save_train_dev_test_split(train_path, dev_path, test_path,
                              stft_magnitudes, stft_phases, mel_spectrograms, labels, segment_names, durations):
    tr_sss = MultilabelStratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=53)
    train_index, dev_test_index = next(tr_sss.split(np.zeros(stft_magnitudes.shape[0]), labels))
    dev_test_sss = MultilabelStratifiedShuffleSplit(n_splits=1, test_size=0.5, random_state=32)
    dev_index, test_index = next(
        dev_test_sss.split(np.zeros(stft_magnitudes[dev_test_index].shape[0]), labels[dev_test_index]))

    save_features(train_path,
                  stft_magnitudes=stft_magnitudes[train_index],
                  stft_phases=stft_phases[train_index],
                  mel_spectrograms=mel_spectrograms[train_index],
                  labels=labels[train_index],
                  segment_names=segment_names[train_index],
                  durations=durations[train_index])

    save_features(dev_path,
                  stft_magnitudes=stft_magnitudes[dev_test_index][dev_index],
                  stft_phases=stft_phases[dev_test_index][dev_index],
                  mel_spectrograms=mel_spectrograms[dev_test_index][dev_index],
                  labels=labels[dev_test_index][dev_index],
                  segment_names=segment_names[dev_test_index][dev_index],
                  durations=durations[dev_test_index][dev_index])

    save_features(test_path,
                  stft_magnitudes=stft_magnitudes[dev_test_index][test_index],
                  stft_phases=stft_phases[dev_test_index][test_index],
                  mel_spectrograms=mel_spectrograms[dev_test_index][test_index],
                  labels=labels[dev_test_index][test_index],
                  segment_names=segment_names[dev_test_index][test_index],
                  durations=durations[dev_test_index][test_index])


def main():
    config = {"length_segments_s": 3.3,  # 3.3

              "audioset_data_folder": '/home/vincent/Audio_blind_source_separation/Datadir/cloud_factorized_audioset/',
              "output_folder": "/home/vincent/Audio_blind_source_separation/Datadir"
                               "/audioset_segments_G_noise_SNR_20_dB",
              # audioset_segments

              "sampling_rate": 16000,

              "STFT_frame_width_ms": 64,
              "STFT_frame_shift_ms": 32,
              "STFT_window_function": "hamming",
              "detrend": False,
              "boundary": None,
              "padded": False,

              "n_Mel_filters": 64,
              "Mel_min_freq": 0,
              "Mel_max_freq": 8000,

              "Add_gaussian_noise": True,
              "G_noise_SNR_in_dB": 20}

    parser = argparse.ArgumentParser(allow_abbrev=False,
                                     description="Generate segments of given length from the 10 seconds audio "
                                                 "segments labelled by Cloud_factory. This program divides the "
                                                 "segments, which are saved as individual .wavs files. It also "
                                                 "computes the STFT magnitude, phase and mel spectrgram, the labels "
                                                 "associated with the segments and the durations of the labelled "
                                                 "portions in each segment. This data is saved in a hdf5 file. "
                                                 "Finally, that data is splitted (stratified split) into training, "
                                                 "development and test set, and each set is saved in a separate .hdf5 "
                                                 "file.")
    parser.add_argument("-l", "--length_segments_s", type=float, default=config['length_segments_s'],
                        help="Length (in seconds) of the segments to generate.")
    parser.add_argument('--audioset_data_folder', type=str, default=config['audioset_data_folder'],
                        help='Path to the folder containing the audioset audio and labels files.')
    parser.add_argument('--output_folder', type=str, default=config['output_folder'],
                        help='Path to the output folder for the generated segments. (Either non existing directory, '
                             'or empty directory)')
    parser.add_argument('--sampling_rate', type=int, default=config['sampling_rate'],
                        help='Sampling rate for the generated segments (the original audio files will be re-sampled '
                             'to this rate before use')
    parser.add_argument('--STFT_frame_width_ms', type=int, default=config['STFT_frame_width_ms'],
                        help='Length of a window frame for the stft computation, in ms.')
    parser.add_argument('--STFT_frame_shift_ms', type=int, default=config['STFT_frame_shift_ms'],
                        help='Shift between each stft window frame, in ms.')
    parser.add_argument('--STFT_window_function', type=str, default=config['STFT_window_function'],
                        help='Name of the window function to use during the stft. See scipy window functions.')
    parser.add_argument('--n_Mel_filters', type=int, default=config['n_Mel_filters'],
                        help='Number of Mel frequency bands to use for the Mel spectrogram.')
    parser.add_argument('--Mel_min_freq', type=int, default=config['Mel_min_freq'],
                        help='Minimal frequency to use on the Mel scale.')
    parser.add_argument('--Mel_max_freq', type=int, default=config['Mel_max_freq'],
                        help='Maximal frequency to use on the Mel scale.')
    parser.add_argument('--Add_gaussian_noise', nargs='?', type=str2bool, default=config['Add_gaussian_noise'],
                        help='Whether or not to add Gaussian noise to the audio segments.')
    parser.add_argument('--G_noise_SNR_in_dB', type=float, default=config['G_noise_SNR_in_dB'],
                        help='SNR between segment audio and added gaussian noise, in dB.')

    parsed_args = vars(parser.parse_known_args()[0])
    config.update(parsed_args)

    STFT_frame_n_samples = int(config["sampling_rate"] / (1000.0 / config["STFT_frame_width_ms"]))
    STFT_frame_n_samples_shift = int(config["sampling_rate"] / (1000.0 / config["STFT_frame_shift_ms"]))

    n_stft_frames_in_segments = (config["length_segments_s"] * config[
        "sampling_rate"] - STFT_frame_n_samples) / STFT_frame_n_samples_shift
    round_segments_length_s = np.round(config["length_segments_s"] * config["sampling_rate"] / STFT_frame_n_samples) \
                              * STFT_frame_n_samples / config["sampling_rate"]
    segment_n_samples = int(round_segments_length_s * config["sampling_rate"])
    new_n_stft_frames_in_segments = int(
        (round_segments_length_s * config["sampling_rate"] - STFT_frame_n_samples) / STFT_frame_n_samples_shift)
    print("Number of STFT frames in a segment with the input parameters: {}".format(n_stft_frames_in_segments))
    print("Rounding the length of the segments to {} seconds"
          ", in order to have exactly {} stft frames in each segment.".format(round_segments_length_s,
                                                                              new_n_stft_frames_in_segments))
    print("There are {} audio samples in a segment.".format(segment_n_samples))

    all_wavs_filenames = [os.path.join(dp, f)
                          for dp, dn, fn in os.walk(os.path.expanduser(config["audioset_data_folder"]))
                          for f in fn
                          if f.endswith('.wav')]

    all_labels_filenames = [os.path.splitext(wav_filename)[0] + '.txt' for wav_filename in all_wavs_filenames]

    classes = [directory for directory in os.listdir(config["audioset_data_folder"])
               if os.path.isdir(os.path.join(config["audioset_data_folder"], directory))] + ['Human Speech']
    config["classes"] = [a_class.replace(' ', '_').lower() for a_class in classes]
    n_classes = len(classes)

    if not os.path.exists(config["output_folder"]):
        os.makedirs(config["output_folder"])
    else:
        if os.listdir(config["output_folder"]):  # if folder is not empty
            raise ValueError('Output folder already exist !')

    # save config
    with open(os.path.join(config["output_folder"], 'config.json'), 'w') as config_file:
        json.dump(config, config_file)

    stft_magnitudes, stft_phases, mel_spectrograms, labels, segment_names, durations = \
        generate_segments(all_wavs_filenames=all_wavs_filenames, all_labels_filenames=all_labels_filenames,
                          config=config, classes=classes, STFT_frame_n_samples=STFT_frame_n_samples,
                          STFT_frame_n_samples_shift=STFT_frame_n_samples_shift, segment_n_samples=segment_n_samples,
                          round_segments_length_s=round_segments_length_s)

    stft_magnitudes, stft_phases, mel_spectrograms, labels, segment_names, durations = \
        merge_remove_duplicates(stft_magnitudes=stft_magnitudes, stft_phases=stft_phases,
                                mel_spectrograms=mel_spectrograms, labels=labels, segment_names=segment_names,
                                durations=durations)

    save_features(os.path.join(config["output_folder"], 'all_data.hdf5'), stft_magnitudes=stft_magnitudes,
                  stft_phases=stft_phases, mel_spectrograms=mel_spectrograms, labels=labels,
                  segment_names=segment_names, durations=durations)

    save_train_dev_test_split(os.path.join(config["output_folder"], 'train_data.hdf5'),
                              os.path.join(config["output_folder"], 'dev_data.hdf5'),
                              os.path.join(config["output_folder"], 'test_data.hdf5'),
                              stft_magnitudes=stft_magnitudes, stft_phases=stft_phases,
                              mel_spectrograms=mel_spectrograms, labels=labels, segment_names=segment_names,
                              durations=durations)


if __name__ == '__main__':
    main()
